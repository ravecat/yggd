// Generated by AshTypescript
// Do not edit this file manually





export type UUID = string;
export type UtcDateTimeUsec = string;

// User Schema
export type UserResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "name";
  id: UUID;
  email: string;
  name: string | null;
  todos: { __type: "Relationship"; __array: true; __resource: TodoResourceSchema; };
};



// Todo Schema
export type TodoResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "content" | "status" | "createdAt" | "updatedAt" | "userId";
  id: UUID;
  title: string;
  content: string;
  status: "todo" | "in_progress" | "completed";
  createdAt: UtcDateTimeUsec;
  updatedAt: UtcDateTimeUsec;
  userId: UUID;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};









export type UserFilterInput = {
  and?: Array<UserFilterInput>;
  or?: Array<UserFilterInput>;
  not?: Array<UserFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };


  todos?: TodoFilterInput;

};
export type TodoFilterInput = {
  and?: Array<TodoFilterInput>;
  or?: Array<TodoFilterInput>;
  not?: Array<TodoFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  status?: {
    eq?: "todo" | "in_progress" | "completed";
    notEq?: "todo" | "in_progress" | "completed";
    in?: Array<"todo" | "in_progress" | "completed">;
  };

  createdAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  updatedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  user?: UserFilterInput;

};


// Utility Types

// Resource schema constraint
type TypedSchema = {
  __type: "Resource" | "TypedStruct" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

// Helper type to infer union field values, avoiding duplication between array and non-array unions
type InferUnionFieldValue<
  UnionSchema extends { __type: "Union"; __primitiveFields: any },
  FieldSelection extends any[],
> = UnionToIntersection<
  {
    [FieldIndex in keyof FieldSelection]: FieldSelection[FieldIndex] extends UnionSchema["__primitiveFields"]
      ? FieldSelection[FieldIndex] extends keyof UnionSchema
        ? { [P in FieldSelection[FieldIndex]]: UnionSchema[FieldSelection[FieldIndex]] }
        : never
      : FieldSelection[FieldIndex] extends Record<string, any>
        ? {
            [UnionKey in keyof FieldSelection[FieldIndex]]: UnionKey extends keyof UnionSchema
              ? UnionSchema[UnionKey] extends { __type: "TypedMap"; __primitiveFields: any }
                ? UnionSchema[UnionKey]
                : UnionSchema[UnionKey] extends TypedSchema
                  ? InferResult<UnionSchema[UnionKey], FieldSelection[FieldIndex][UnionKey]>
                  : never
              : never;
          }
        : never;
  }[number]
>;

type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : T[K] extends { __type: "Union"; __primitiveFields: infer PrimitiveFields }
        ? T[K] extends { __array: true }
          ? (PrimitiveFields | {
              [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields" | "__array">]?: T[K][UnionKey] extends { __type: "TypedMap"; __primitiveFields: any }
                ? T[K][UnionKey]["__primitiveFields"][]
                : T[K][UnionKey] extends TypedSchema
                  ? UnifiedFieldSelection<T[K][UnionKey]>[]
                  : never;
            })[]
          : (PrimitiveFields | {
              [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields">]?: T[K][UnionKey] extends { __type: "TypedMap"; __primitiveFields: any }
                ? T[K][UnionKey]["__primitiveFields"][]
                : T[K][UnionKey] extends TypedSchema
                  ? UnifiedFieldSelection<T[K][UnionKey]>[]
                  : never;
            })[]
          : NonNullable<T[K]> extends TypedSchema
            ? UnifiedFieldSelection<NonNullable<T[K]>>[]
            : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : T[K] extends { __type: "Union"; __primitiveFields: any }
              ? T[K] extends { __array: true }
                ? {
                    [CurrentK in K]: T[CurrentK] extends { __type: "Union"; __primitiveFields: any }
                      ? Field[CurrentK] extends any[]
                        ? Array<InferUnionFieldValue<T[CurrentK], Field[CurrentK]>> | null
                        : never
                      : never
                  }
                : {
                    [CurrentK in K]: T[CurrentK] extends { __type: "Union"; __primitiveFields: any }
                      ? Field[CurrentK] extends any[]
                        ? InferUnionFieldValue<T[CurrentK], Field[CurrentK]> | null
                        : never
                      : never
                  }
                : NonNullable<T[K]> extends TypedSchema
                  ? null extends T[K]
                    ? InferResult<NonNullable<T[K]>, Field[K]> | null
                    : InferResult<NonNullable<T[K]>, Field[K]>
                  : never
          : never;
      }
    : never;

type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[],
> = UnionToIntersection<
  {
    [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
  }[number]
>;

// Pagination conditional types
// Checks if a page configuration object has any pagination parameters
type HasPaginationParams<Page> =
  Page extends { offset: any } ? true :
  Page extends { after: any } ? true :
  Page extends { before: any } ? true :
  false;

// Infer which pagination type is being used from the page config
type InferPaginationType<Page> =
  Page extends { offset: any } ? "offset" :
  Page extends { after: any } | { before: any } ? "keyset" :
  never;

// Returns either non-paginated (array) or paginated result based on page params
// For single pagination type support (offset-only or keyset-only)
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
type ConditionalPaginatedResult<
  Page,
  RecordType,
  PaginatedType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? PaginatedType
    : RecordType;

// For actions supporting both offset and keyset pagination
// Infers the specific pagination type based on which params were passed
type ConditionalPaginatedResultMixed<
  Page,
  RecordType,
  OffsetType,
  KeysetType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? InferPaginationType<Page> extends "offset"
      ? OffsetType
      : InferPaginationType<Page> extends "keyset"
        ? KeysetType
        : OffsetType | KeysetType  // Fallback to union if can't determine
    : RecordType;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call
 * @example
 * const error: AshRpcError = { type: "validation_error", message: "Something went wrong" }
 */
export type AshRpcError = {
  type: string;
  message: string;
  field?: string;
  fieldPath?: string;
  details?: Record<string, any>;
}





// Helper Functions

/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}





export type GetByEmailInput = {
  email: string;
};

export type GetByEmailValidationErrors = {
  email?: string[];
};

export type GetByEmailFields = UnifiedFieldSelection<UserResourceSchema>[];
type InferGetByEmailResult<
  Fields extends GetByEmailFields,
> = InferResult<UserResourceSchema, Fields> | null;

export type GetByEmailResult<Fields extends GetByEmailFields> = | { success: true; data: InferGetByEmailResult<Fields>; }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function getByEmail<Fields extends GetByEmailFields>(
  config: {
  input: GetByEmailInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetByEmailResult<Fields>> {
  let processedConfig = config;

  const payload = {
    action: "get_by_email",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as GetByEmailResult<Fields>;
}


export type ValidateGetByEmailResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateGetByEmail(
  config: {
  input: GetByEmailInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateGetByEmailResult> {
  let processedConfig = config;

  const payload = {
    action: "get_by_email",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ValidateGetByEmailResult;
}


export type ListUsersFields = UnifiedFieldSelection<UserResourceSchema>[];


type InferListUsersResult<
  Fields extends ListUsersFields,
  Page extends ListUsersConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<UserResourceSchema, Fields>>, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListUsersConfig = {
  fields: ListUsersFields;
  filter?: UserFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListUsersResult<Fields extends ListUsersFields, Page extends ListUsersConfig["page"] = undefined> = | { success: true; data: InferListUsersResult<Fields, Page>; }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listUsers<Fields extends ListUsersFields, Config extends ListUsersConfig>(
  config: Config & { fields: Fields }
): Promise<ListUsersResult<Fields, Config["page"]>> {
  let processedConfig = config;

  const payload = {
    action: "list_users",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ListUsersResult<Fields, Config["page"]>;
}


export type ValidateListUsersResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListUsers(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListUsersResult> {
  let processedConfig = config;

  const payload = {
    action: "list_users"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ValidateListUsersResult;
}


export type ListTodosFields = UnifiedFieldSelection<TodoResourceSchema>[];


type InferListTodosResult<
  Fields extends ListTodosFields,
  Page extends ListTodosConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<TodoResourceSchema, Fields>>, {
  results: Array<InferResult<TodoResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<TodoResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListTodosConfig = {
  fields: ListTodosFields;
  filter?: TodoFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListTodosResult<Fields extends ListTodosFields, Page extends ListTodosConfig["page"] = undefined> = | { success: true; data: InferListTodosResult<Fields, Page>; }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function listTodos<Fields extends ListTodosFields, Config extends ListTodosConfig>(
  config: Config & { fields: Fields }
): Promise<ListTodosResult<Fields, Config["page"]>> {
  let processedConfig = config;

  const payload = {
    action: "list_todos",
    fields: config.fields,
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ListTodosResult<Fields, Config["page"]>;
}


export type ValidateListTodosResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateListTodos(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateListTodosResult> {
  let processedConfig = config;

  const payload = {
    action: "list_todos"
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ValidateListTodosResult;
}


export type CreateTodoInput = {
  title: string;
  content: string;
  status?: "todo" | "in_progress" | "completed";
  userId: UUID;
};

export type CreateTodoValidationErrors = {
  title?: string[];
  content?: string[];
  status?: string[];
  userId?: string[];
};

export type CreateTodoFields = UnifiedFieldSelection<TodoResourceSchema>[];

type InferCreateTodoResult<
  Fields extends CreateTodoFields,
> = InferResult<TodoResourceSchema, Fields>;

export type CreateTodoResult<Fields extends CreateTodoFields> = | { success: true; data: InferCreateTodoResult<Fields>; }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function createTodo<Fields extends CreateTodoFields>(
  config: {
  input: CreateTodoInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateTodoResult<Fields>> {
  let processedConfig = config;

  const payload = {
    action: "create_todo",
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as CreateTodoResult<Fields>;
}


export type ValidateCreateTodoResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateCreateTodo(
  config: {
  input: CreateTodoInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateCreateTodoResult> {
  let processedConfig = config;

  const payload = {
    action: "create_todo",
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ValidateCreateTodoResult;
}


export type UpdateTodoInput = {
  title: string;
  content: string;
  status?: "todo" | "in_progress" | "completed";
};

export type UpdateTodoValidationErrors = {
  title?: string[];
  content?: string[];
  status?: string[];
};

export type UpdateTodoFields = UnifiedFieldSelection<TodoResourceSchema>[];

type InferUpdateTodoResult<
  Fields extends UpdateTodoFields,
> = InferResult<TodoResourceSchema, Fields>;

export type UpdateTodoResult<Fields extends UpdateTodoFields> = | { success: true; data: InferUpdateTodoResult<Fields>; }
| {
    success: false;
    errors: Array<{
      type: string;
      message: string;
      fieldPath?: string;
      details: Record<string, string>;
    }>;
  }
;

export async function updateTodo<Fields extends UpdateTodoFields>(
  config: {
  primaryKey: UUID;
  input: UpdateTodoInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateTodoResult<Fields>> {
  let processedConfig = config;

  const payload = {
    action: "update_todo",
    primaryKey: config.primaryKey,
    input: config.input,
    fields: config.fields
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as UpdateTodoResult<Fields>;
}


export type ValidateUpdateTodoResult =
  | { success: true }
  | {
      success: false;
      errors: Array<{
        type: string;
        message: string;
        field?: string;
        fieldPath?: string;
        details?: Record<string, any>;
      }>;
    };


export async function validateUpdateTodo(
  config: {
  primaryKey: string;
  input: UpdateTodoInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidateUpdateTodoResult> {
  let processedConfig = config;

  const payload = {
    action: "update_todo",
    primaryKey: config.primaryKey,
    input: config.input
  };

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);

  const result = response.ok ? await response.json() : null;

  

  if (!response.ok) {
    return {
      success: false,
      errors: [{ type: "network", message: response.statusText, details: {} }],
    };
  }

  return result as ValidateUpdateTodoResult;
}


